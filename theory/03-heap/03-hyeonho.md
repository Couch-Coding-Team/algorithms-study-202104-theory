# 힙

**힙**은 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 **완전이진트리**를 기본으로 한 자료구조로서 다음과 같은 힙 속성을 만족한다.

- A가 B의 부모노드이면, A의 키값과 B의 키값 사이에는 대소관계가 성립한다.

 힙에는 두가지 종류가 있으며, 부모노드의 키값이 자식노드의 키값보다 항상 큰 힙을 '**최대 힙**', 부모노드의 키값이 자식노드의 키값보다 항상 작은 힙을 **'최소 힙**'이라고 부른다. 키값의 대소관계는 오로지 부모노드와 자식노드 간에만 성립하며, 특히 형제 사이에는 대소관계가 정해지지 않는다.

각 노드의 자식노드의 최대개수는 힙의 종류에 따라 다르지만, 대부분의 경우는 자식노드의 개수가 최대 2개인 이진힙을 사용한다.

힙에서는 가장 높은(혹은 가장 낮은) 우선순위를 가지는 노드가 항상 뿌리노드에 오게 되는 특징이 있으며, 이를 응용하면 우선순위 큐와 같은 추상적 자료형을 구현할 수 있다.

출처 : [위키백과]([https://ko.wikipedia.org/wiki/힙_(자료_구조)](https://ko.wikipedia.org/wiki/%ED%9E%99_(%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0)))

힙에서 자주 언급되는 키워드인 완전 이진 트리, 최대힙, 최소힙에 대해 알아보자

## 완전 이진 트리

완전이진트리는 두개의 자식 노드만 가지며 왼쪽부터 차례대로 채워지는 트리를 말한다. 그림으로 보면 더 쉽게 이해가 된다.

![스크린샷 2021-04-26 오후 8 55 39](https://user-images.githubusercontent.com/58363663/116087840-3d83dd00-a6dc-11eb-824a-178fb52a0252.png)


완전 이진트리의 속성으로는 레벨 k에 있는 최대 노드의 수는 2^(k-1)이다. 위 첫번째 그림을 예시로 레벨 3에있는 최대 노드의 수는 2^2 = 4개다.

포화이진트리를 기준으로 총 노드의 수는 2^(h-1)이다. 

### heapify

완전 이진 트리는 배열로도 구현이 가능하다. 완전 이진 트리의 특성으로 마지막 레벨을 제외한 나머지가 모두 2개의 노드 쌍으로 이루어졌기 때문에 중간이 비어있을 수 없다.

![스크린샷 2021-04-26 오후 10 12 19](https://user-images.githubusercontent.com/58363663/116088113-863b9600-a6dc-11eb-9c09-80b8461e0621.png)


다음과 같은 공식을 세울 수 있다.

- array[i]의 부모는 a[i / 2]에 있다. (단, i > 1)
- array[i]의 왼쪽 자식은 a[2 * i]에 있다. (단, 2 * i ≤ N)
- array[i]의 오른쪽 자식은 a[2 * i + 1]에 있다. (단, 2 * i ≤ N)

## 최대힙

- 최대 트리는 각 노드의 키값이 (자식 노드가 있다면) 그 자식의 키값보다 작지 않은(=크거나 같은) 트리이다.
- 최대 힙은 최대 트리이면서 완전 이진 트리이다.

  ![스크린샷 2021-04-26 오후 9 32 11](https://user-images.githubusercontent.com/58363663/116088231-a53a2800-a6dc-11eb-9940-3fc0b233bf05.png)


## 최소힙

- 최소 트리는 각 노드의 키값이 (자식 노드가 있다면) 그 자식의 키값보다 크지 않은 트리이다.
- 최소 힙은 최소 트리이면서 완전 이진 트리이다.
  
  ![스크린샷 2021-04-26 오후 9 32 02](https://user-images.githubusercontent.com/58363663/116088166-93588500-a6dc-11eb-8a3f-90e5eb57d901.png)


## 시간 복잡도

### 삽입

8이 새로 들어왔고 가장 마지막 자리에 추가되었다. 

그 다음 부모노드와 비교한다. 부모 노드 보다 크므로 위치를 바꾼다.

![스크린샷 2021-04-26 오후 9 34 32](https://user-images.githubusercontent.com/58363663/116088264-ac613600-a6dc-11eb-90e0-51d212db9eaf.png)

![_2021-04-26__9 35 33](https://user-images.githubusercontent.com/58363663/116088667-09f58280-a6dd-11eb-8f41-ee74febef4eb.png)



위치를 바꾸고 난 후 다시 부모 노드와 비교한다. 8이 더 작으므로 끝낸다.

이런식으로 부모노드와 비교하며 힙을 만든다. 비교할 때 마다 노드가 절반씩 줄어들기 때문에 시간복잡도는 **O(logN)**이다.

### 삭제

힙의 삭제는 루트 노드에서 이뤄진다. 9가 삭제되고 가장 마지막 노드가 루트 노드가 된다.


![스크린샷 2021-04-26 오후 9 39 25](https://user-images.githubusercontent.com/58363663/116088341-bdaa4280-a6dc-11eb-8997-0c6dd8b67775.png)

![스크린샷 2021-04-26 오후 9 39 52](https://user-images.githubusercontent.com/58363663/116088336-bc791580-a6dc-11eb-8fe9-ccb45229a451.png)


삽입과는 반대로 루트부터 자식을 비교한다.

![_2021-04-26__9 35 33](https://user-images.githubusercontent.com/58363663/116088802-2a254180-a6dd-11eb-8ca5-ba70ff82e2aa.png)


삽입과 마찬가지로 동일한 과정을 반대로만 할뿐이므로 시간복잡도는 **O(longN)**이다.
