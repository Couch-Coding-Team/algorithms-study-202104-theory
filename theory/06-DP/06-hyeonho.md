# **동적 계획법(Dynamic Programming, DP)**

동적 계획법(Dynamic Programming, DP)은 큰 문제를 작은 문제로 나눠서 푸는 알고리즘이다.

동적 계획법(Dynamic Programming)은 이름만으로 무엇을 의미하는지 알 수 없기 때문에 오해가 많이 생기는데,동적 계획법(Dynamic Programming)이라는 말을 처음 사용한 벨만은, Dynamic 이라는 단어가 멋있어서 선택했다고 한다.

동적 계획법은 처음 주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계산하고, 이 답들로부터 원래 문제에 대한 답을 계산해 낸다는 점에서 분할 정복(Divide & Conquer, D&C)과 비슷하다. 하지만 가장 큰 차이점은 동적 계획법에서는 쪼개진 작은 문제가 중복되지만, 분할 정복은 절대로 중복될수가 없다는 점이다


## 1. 동적 계획법의 조건

두 가지 속성을 만족해야 동적 계획법으로 문제를 풀 수 있다.

 **Overlapping Subproblem** : 겹치는 부분(작은) 문제

 **Optimal Substructure** : 최적 부분구조

## 2. 메모이제이션(Memoization)

 동적 계획법에서 각 문제는 **한 번만** 풀어야 한다. 중복되는 부분 문제를 여러번 풀지 않는다는 뜻이다. Optimal Substructure를 만족하기 때문에 같은 문제는 구할 때마다 정답이 같다. 따라서 정답을 한 번 구했으면 그 정답을 캐시에 메모해놓는다. 이렇게 메모하는 것을 코드의 구현에서는 배열에 저장하는 것으로 할 수 있다. 이를 메모이제이션(Memoization)이라고 한다. 

 위의 피보나치 문제를 풀어보았다면 배열에 값을 미리 저장시켜서 같은 문제를 반복하지 않은 것을 알 수 있다.

## **3. TOP - DOWN**

1. 큰 문제를 작은 문제로 나눈다.
2. 작은 문제를 푼다.
3. 작은 문제를 풀었으니, 이제 큰 문제를 푼다.

재귀와 같은 방식으로 **위에서 아래로 내려오는 방식이다.**

**함수 호출을 줄이기 위해,** 앞서 말했던 **메모이제이션을 사용한다.**

(a) 일반 재귀

```java
public int fibonacci(int n) { 
    if (n == 1 || n == 2) {
        return 1;
		}
    return fibonacci(n - 1) + fibonacci(n - 2);
}

```

(b) 메모이제이션을 적용한 TOP-DOWN방식 

```java
public int fibonacci(int n){
    if (n == 1 || n == 2) {
        return 1;
    }
    if (memo[n]) {
        return memo[n];
    }

    memo[n] = fib(n-1) + fib(n-2);
    return memo[n];
}
```

## 5. Bottom-up

1. 문제를 크기가 작은 문제부터 차례대로 푼다.
2. 문제의 크기를 조금씩 크게 만들면서 문제를 점점 푼다.
3. 작은 문제를 풀면서 왔기 때문에, 큰 문제는 항상 풀 수 있다.
4. 반복하다 보면 가장 큰 문제를 풀 수 있다.

```java
int d[100];

int fibonacci(int n) {
    d[0] = 0;
    d[1] = 1;
    for (int i = 2; i <= n; i++) {	
    	d[i] = d[i-1] + d[i-2];
    }
    return d[n];
}
```

## 6.. 동적 계획법을 통한 문제풀이

- 먼저, 문제에서 구하려고 하는 답을 문장으로 나타낸다.
- (예: 피보나치 수를 구하는 문제 -> N번째 피보나치 수)
- 이제 그 문장에 나와있는 변수의 개수만큼 메모하는 캐시 배열을 만든다.
- Top-down인 경우에는 재귀 호출의 인자의 개수가 된다.
- 마지막으로, 문제를 작은 문제로 나누고, 수식(점화식)을 이용해서 문제를 표현해야 한다.
