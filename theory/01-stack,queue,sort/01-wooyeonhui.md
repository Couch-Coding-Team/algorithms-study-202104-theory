# Queue, Stack, Sort
## 큐 (Queue)
 FIFO(First In First Out),  LILO(Last In Last Out)
 음식점에 줄서기
 <-> 스택 (Stack)

 기능
 - Enqueue : 큐에 데이터를 넣음
 - Dequeue : 큐에 데이터를 뺌

 LIFO(Last In First Out) Queue

 ## Stack
 LIFO(Last In First Out), FILO(First In Last Out)
 - 대표적인 스택의 활용 : 컴퓨터 내부의 프로세스 구조의 함수 동작 방식
 - 주요기능
  1. push() : 데이터를 스택에 쌓기
  2. pop() : 데이터를 스택에서 꺼내기

 - 스택 구조는 프로세스 실행 구조의 가장 기본
 - 함수 호출 시 프로세스 실행 구조를 스택과 비교해서 이해 필요

### 장점
- 구조가 단순해서, 구현이 쉽다.
- 데이터 저장/ 읽기 속도가 빠르다

### 단점
- 데이터 최대 개수를 미리 정해야 한다.

 -> 파이썬의 경우 재귀 함수는 1000번까지만 호출이 가능함

- 저장 공간의 낭비가 발생할 수 있음

 -> 미리 최대 갯수만큼 저장 공간을 확보해야 함

## Sort
1. 선택 정렬 (Selection Sort)
    1번째부터 끝까지 훑어서 가장 작은 게 1번째, 2번째부터 끝까지 훑어서 가장 작은 게 2번째……해서 (n-1)번 반복한다. 어찌 보면 인간이 사용하는 정렬 방식을 가장 많이 닮았다.
    어떻게 정렬이 되어 있든 일관성 있게 n(n-1)/2
    에 비례하는 시간이 걸린다는 게 특징. 또한, 버블 정렬보다 두 배 정도 빠르다

2. 삽입 정렬 (Insertion Sort)|
    k번째 원소를 1부터 k-1까지와 비교해 적절한 위치에 끼워넣고 그 뒤의 자료를 한 칸씩 뒤로 밀어내는 방식으로, 평균적으론 O(n^2)
    중 빠른 편이나 자료구조에 따라선 뒤로 밀어내는데 걸리는 시간이 크며, 앞의 예시처럼 작은 게 뒤쪽에 몰려있으면(내림차순의 경우 큰 게 뒤쪽에 몰려있으면) 최악의 경우가 발생한다.

3. 버블 정렬 (Bubble Sort)
    거의 모든 상황에서 최악의 성능을 보여준다. 단, 이미 정렬된 자료에서는 1번만 돌면 되기 때문에 최선의 성능을 보여준다. 이미 정렬된 자료를 정렬하는 바보짓을 왜 하냐는 의문이 들 수 있지만, 정렬 알고리즘은 자료가 정렬되어 있는지 아닌지는 모르고 작동하기 때문에 의미가 있다.
    가장 손쉽게 구현하여 사용할 수 있지만, 만들기가 쉽고 직관적일 뿐이지 알고리즘적 관점에서 보면 대단히 비효율적인 정렬 방식이다.

4. 합병 정렬 (Merge Sort)
    대표적인 분할 정복 알고리즘

5. 퀵 정렬 (Quick Sort)
    평균적인 상황에서 최고의 성능을 나타낸다.
    컴퓨터로 가장 많이 구현된 정렬 알고리즘 중 하나이다. 

    원소 하나를 기준(피벗, pivot)으로 삼아 그보다 작은 것을 앞으로 빼내고 그 뒤에 피벗을 옮겨 피벗보다 작은 것, 큰 것으로 나눈뒤 나누어진 각각에서 다시 피벗을 잡고 정렬해서 각각의 크기가 0이나 1이 될 때까지 정렬한다.

